/**
 * Assessment Service
 * Business logic for assessment operations (PDF merge, compression, etc.)
 */

const formSubmissionRepository = require('../repositories/formSubmissionRepository');
const { AppError } = require('../middleware/errorHandler');
const axios = require('axios');
const { PDFDocument: PDFLibDocument, rgb } = require('pdf-lib');
const fs = require('fs');
const path = require('path');
const archiver = require('archiver');

class AssessmentService {
  /**
   * Get submission by ID for assessment operations
   */
  async getSubmissionForAssessment(submissionId) {
    const submission = await formSubmissionRepository.findById(submissionId);
    if (!submission) {
      throw new AppError('Submission not found', 404);
    }
    return submission;
  }

  /**
   * Merge PDFs from submission
   */
  async mergePDFs(submissionId, documentIds, customerName, customerEmail, filename) {
    const submission = await this.getSubmissionForAssessment(submissionId);

    // Filter documents by selected IDs
    const selectedDocuments = submission.documents.filter(doc =>
      documentIds.includes(doc._id.toString())
    );

    if (selectedDocuments.length === 0) {
      throw new AppError('No documents selected', 400);
    }

    // Create a new PDF document using pdf-lib
    const mergedPdf = await PDFLibDocument.create();

    // Add cover page
    const coverPage = mergedPdf.addPage([595, 842]);
    const { width, height } = coverPage.getSize();

    coverPage.drawText('Documents Assessment', {
      x: 50,
      y: height - 100,
      size: 24,
      color: rgb(0, 0, 0)
    });

    coverPage.drawText(`Customer: ${customerName}`, {
      x: 50,
      y: height - 150,
      size: 14,
      color: rgb(0, 0, 0)
    });

    coverPage.drawText(`Email: ${customerEmail}`, {
      x: 50,
      y: height - 170,
      size: 14,
      color: rgb(0, 0, 0)
    });

    coverPage.drawText(`Date: ${new Date().toLocaleDateString()}`, {
      x: 50,
      y: height - 190,
      size: 14,
      color: rgb(0, 0, 0)
    });

    // Process each document
    for (let i = 0; i < selectedDocuments.length; i++) {
      const document = selectedDocuments[i];
      await this.embedDocument(mergedPdf, document, i);
    }

    // Add footer to last page
    const pages = mergedPdf.getPages();
    if (pages.length > 0) {
      const lastPage = pages[pages.length - 1];
      const { width, height } = lastPage.getSize();

      lastPage.drawText('Generated by Wise Steps Consultant', {
        x: 50,
        y: 50,
        size: 10,
        color: rgb(0.5, 0.5, 0.5)
      });

      lastPage.drawText(`Generated on: ${new Date().toISOString()}`, {
        x: 50,
        y: 30,
        size: 8,
        color: rgb(0.5, 0.5, 0.5)
      });
    }

    // Save merged PDF
    const safeFilename = (filename || customerName || 'merged_documents').replace(/[^a-zA-Z0-9_-]/g, '_');
    const fileName = `${safeFilename}_${Date.now()}.pdf`;
    const filePath = path.join(__dirname, '../uploads', fileName);

    const mergedPdfBytes = await mergedPdf.save();
    fs.writeFileSync(filePath, mergedPdfBytes);

    return { filePath, fileName };
  }

  /**
   * Embed document into PDF
   */
  async embedDocument(mergedPdf, document, index) {
    try {
      if (!document.cloudinaryUrl) {
        this.createPlaceholderPage(mergedPdf, document, index, 'Document not available');
        return;
      }

      const response = await axios.get(document.cloudinaryUrl, {
        responseType: 'arraybuffer'
      });

      if (document.mimetype === 'application/pdf') {
        const pdfBytes = response.data;
        const pdfDoc = await PDFLibDocument.load(pdfBytes);
        const pages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());

        pages.forEach(page => {
          mergedPdf.addPage(page);
        });
      } else if (document.mimetype.startsWith('image/')) {
        await this.embedImage(mergedPdf, document, response.data, index);
      } else {
        this.createPlaceholderPage(mergedPdf, document, index);
      }
    } catch (error) {
      console.error(`Error embedding document ${document.originalname}:`, error);
      this.createPlaceholderPage(mergedPdf, document, index, 'Error embedding document');
    }
  }

  /**
   * Embed image into PDF
   */
  async embedImage(mergedPdf, document, imageBytes, index) {
    const imagePage = mergedPdf.addPage([595, 842]);
    const { width, height } = imagePage.getSize();

    let image;
    if (document.mimetype === 'image/jpeg' || document.mimetype === 'image/jpg') {
      image = await mergedPdf.embedJpg(imageBytes);
    } else if (document.mimetype === 'image/png') {
      image = await mergedPdf.embedPng(imageBytes);
    } else {
      image = await mergedPdf.embedPng(imageBytes);
    }

    const imgDims = image.scale(1);
    const scale = Math.min((width - 100) / imgDims.width, (height - 150) / imgDims.height);
    const scaledWidth = imgDims.width * scale;
    const scaledHeight = imgDims.height * scale;
    const x = (width - scaledWidth) / 2;
    const y = height - 100 - scaledHeight;

    imagePage.drawText(`Document ${index + 1}: ${document.fieldName}`, {
      x: 50,
      y: height - 50,
      size: 16,
      color: rgb(0, 0, 0)
    });

    imagePage.drawText(`File: ${document.originalname}`, {
      x: 50,
      y: height - 70,
      size: 12,
      color: rgb(0.5, 0.5, 0.5)
    });

    imagePage.drawImage(image, {
      x: x,
      y: y,
      width: scaledWidth,
      height: scaledHeight
    });
  }

  /**
   * Create placeholder page
   */
  createPlaceholderPage(mergedPdf, document, index, errorMessage = null) {
    const placeholderPage = mergedPdf.addPage([595, 842]);
    const { width, height } = placeholderPage.getSize();

    placeholderPage.drawText(`Document ${index + 1}: ${document.fieldName}`, {
      x: 50,
      y: height - 100,
      size: 16,
      color: rgb(0, 0, 0)
    });

    placeholderPage.drawText(`File: ${document.originalname}`, {
      x: 50,
      y: height - 130,
      size: 14,
      color: rgb(0, 0, 0)
    });

    if (errorMessage) {
      placeholderPage.drawText(errorMessage, {
        x: 50,
        y: height - 160,
        size: 12,
        color: rgb(0.8, 0.2, 0.2)
      });
    } else {
      placeholderPage.drawText(`Type: ${document.mimetype}`, {
        x: 50,
        y: height - 150,
        size: 14,
        color: rgb(0, 0, 0)
      });

      placeholderPage.drawText(`Size: ${(document.size / 1024 / 1024).toFixed(2)} MB`, {
        x: 50,
        y: height - 170,
        size: 14,
        color: rgb(0, 0, 0)
      });
    }
  }

  /**
   * Compress PDFs
   */
  async compressPDFs(submissionId, documentIds, compressionLevel, customerName) {
    if (!submissionId || !documentIds || !Array.isArray(documentIds) || documentIds.length === 0) {
      throw new AppError('Submission ID and document IDs are required', 400);
    }

    const submission = await this.getSubmissionForAssessment(submissionId);

    const documentsToCompress = submission.documents.filter(doc =>
      documentIds.includes(doc._id.toString()) &&
      doc.cloudinaryUrl &&
      doc.mimetype === 'application/pdf'
    );

    if (documentsToCompress.length === 0) {
      throw new AppError('No valid PDF documents found to compress', 400);
    }

    const tempDir = path.join(__dirname, '../uploads', `temp_${Date.now()}`);
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    const compressedFiles = [];

    for (const doc of documentsToCompress) {
      try {
        const response = await axios({
          method: 'GET',
          url: doc.cloudinaryUrl,
          responseType: 'stream'
        });

        const tempFilePath = path.join(tempDir, `${doc._id}_${doc.originalname}`);
        const writeStream = fs.createWriteStream(tempFilePath);

        response.data.pipe(writeStream);

        await new Promise((resolve, reject) => {
          writeStream.on('finish', resolve);
          writeStream.on('error', reject);
        });

        const pdfBytes = fs.readFileSync(tempFilePath);
        const originalSize = pdfBytes.length;
        const targetSize = 4.9 * 1024 * 1024;

        let compressedBytes = await this.compressPDF(pdfBytes, originalSize, targetSize, compressionLevel);

        const compressedPath = path.join(tempDir, `compressed_${doc._id}_${doc.originalname}`);
        fs.writeFileSync(compressedPath, compressedBytes);

        compressedFiles.push({
          path: compressedPath,
          filename: `compressed_${doc.originalname}`
        });

        fs.unlinkSync(tempFilePath);
      } catch (error) {
        console.error(`Error processing document ${doc.originalname}:`, error);
      }
    }

    if (compressedFiles.length === 0) {
      fs.rmSync(tempDir, { recursive: true, force: true });
      throw new AppError('Failed to compress any documents', 500);
    }

    // Create ZIP file
    const zipPath = path.join(tempDir, `${customerName || 'compressed'}_pdfs.zip`);
    await this.createZipFile(compressedFiles, zipPath);

    return { zipPath, zipFileName: `${customerName || 'compressed'}_pdfs.zip`, tempDir };
  }

  /**
   * Compress PDF
   */
  async compressPDF(pdfBytes, originalSize, targetSize, compressionLevel) {
    const pdfDoc = await PDFLibDocument.load(pdfBytes);

    if (originalSize > 10 * 1024 * 1024) {
      // Smart compression for large files
      let compressedBytes = pdfBytes;
      let currentQuality = 1.0;
      let attempts = 0;
      const maxAttempts = 5;

      while (compressedBytes.length > targetSize && attempts < maxAttempts) {
        attempts++;
        const compressionRatio = Math.min(0.9, targetSize / compressedBytes.length);
        currentQuality = Math.max(0.3, currentQuality * compressionRatio);

        compressedBytes = await pdfDoc.save({
          useObjectStreams: true,
          compress: true,
          imageQuality: Math.max(0.5, currentQuality),
          removeMetadata: attempts > 2
        });
      }

      return compressedBytes;
    } else {
      // Standard compression
      let quality;
      switch (compressionLevel) {
        case 'low': quality = 0.8; break;
        case 'medium': quality = 0.6; break;
        case 'high': quality = 0.4; break;
        default: quality = 0.6;
      }

      return await pdfDoc.save({
        useObjectStreams: true,
        compress: true,
        imageQuality: quality
      });
    }
  }

  /**
   * Create ZIP file
   */
  async createZipFile(files, zipPath) {
    return new Promise((resolve, reject) => {
      const output = fs.createWriteStream(zipPath);
      const archive = archiver('zip', { zlib: { level: 9 } });

      output.on('close', resolve);
      archive.on('error', reject);

      archive.pipe(output);
      files.forEach(file => {
        archive.file(file.path, { name: file.filename });
      });
      archive.finalize();
    });
  }
}

module.exports = new AssessmentService();

